# -*- coding: utf-8 -*-
"""CSE422_10_Lab_Assignment02_Summer2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1prvgDrFSLrWDBM-HSbDxsPqDRxBfEiW8
"""

#part1

import random

class schedule:
    def __init__(self, n, t, total_chromo, max_depth, mutation_rate=0.1):
        self.n = n
        self.t = t
        self.total_chromo = total_chromo
        self.max_depth = max_depth
        self.mutation_rate = mutation_rate #10%
        self.chromoList = self.chromosome_generate()

    def chromosome_generate(self):
        chromoList = []
        for i in range(self.total_chromo):
            chromosome = [random.randint(0, 1) for c in range(self.n * self.t)]
            chromoList.append(chromosome)

        #print(population)
        return chromoList

    def genetic_algorithm(self):
        generation_depth = 0
        best_fit = float('-inf')
        best_list = None

        while generation_depth < self.max_depth:
            fitness_list = [self.fitness(chromosome) for chromosome in self.chromoList]
            #print(fitness_list)
            max_fit = max(fitness_list)
            if max_fit > best_fit:
                best_fit = max_fit
                best_list = self.chromoList[fitness_list.index(max_fit)]

            new_chromosomeList = []

            for i in range(self.total_chromo // 2):
                parent1, parent2 = self.select_parents(fitness_list)
                offspring1, offspring2 = self.crossover(parent1, parent2)
                child1 = self.mutate(offspring1)
                child2 = self.mutate(offspring2)
                new_chromosomeList.extend([child1, child2])

            self.chromoList = new_chromosomeList
            generation_depth += 1

        return best_list, best_fit

    def fitness(self, chromosome):
        overlap_penalty = 0
        consistency_penalty = 0

        # overlap penalty
        for t in range(self.t):
            same_slot = sum(chromosome[t * self.n:(t + 1) * self.n])
            if same_slot > 1:
                overlap_penalty += (same_slot - 1)
        # consistency penalty
        for n in range(self.n):
            repeat_course = sum(chromosome[n::self.n])
            consistency_penalty += abs(repeat_course - 1)

        return  -(overlap_penalty + consistency_penalty)

    def select_parents(self, fitness_list):
        total_fitness = sum(fitness_list)
        fitness_probs = [fitness / total_fitness for fitness in fitness_list]
        parent1 = random.choices(self.chromoList, weights=fitness_probs)[0]
        parent2 = random.choices(self.chromoList, weights=fitness_probs)[0]
        return parent1, parent2

    def crossover(self, parent1, parent2):
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = parent1[:crossover_point] + parent2[crossover_point:]
        child2 = parent2[:crossover_point] + parent1[crossover_point:]
        return child1, child2

    def mutate(self, chromosome):
        for i in range(len(chromosome)):
            if random.random() < self.mutation_rate:
                chromosome[i] = 1 - chromosome[i] #if 1, then 0. if 0  then 1.
        return chromosome

with open("CSE422_10_Lab_Assignment02_InputFile_Summer2024.txt", 'r') as f1:
    first_line = f1.readline().strip()
    number_of_courses, number_of_timeslots = map(int, first_line.split())

    if number_of_timeslots < number_of_courses:
        raise ValueError("Number of timeslots T should be greater than or equal to the number of courses N")

    courses = []
    for i in range(number_of_courses):
        courses.append(f1.readline().strip())

total_chromo = 20
max_depth = 1000

optimized_schedule = schedule(number_of_courses, number_of_timeslots, total_chromo, max_depth)
s, f = optimized_schedule.genetic_algorithm()

print("Best Solution:", ''.join(map(str, s)))
print("Fitness:", f)

with open("CSE422_10_Lab_Assignment02_OutputFile_Summer2024.txt", "w") as f2:
    f2.write("Best Solution: " + ''.join(map(str, s)) + "\n")
    f2.write("Fitness: " + str(f) + "\n")

#Part2

def two_point_crossover(self):
    parent1 = random.choice(self.chromoList)
    parent2 = random.choice(self.chromoList)

    print("Parent1: ",''.join(map(str,parent1)))
    print("Parent2: ", ''.join(map(str,parent2)))

    crossover_point1 = random.randint(1, len(parent1) - 2)
    crossover_point2 = random.randint(crossover_point1 + 1, len(parent1) - 1)
    print(crossover_point1, crossover_point2)

    child1 = parent1[:crossover_point1] + parent2[crossover_point1:crossover_point2] + parent1[crossover_point2:]
    child2 = parent2[:crossover_point1] + parent1[crossover_point1:crossover_point2] + parent2[crossover_point2:]

    print("Child1 : ",''.join(map(str,child1)))
    print("Child2 : ",''.join(map(str,child1)))

two_point_crossover(optimized_schedule)